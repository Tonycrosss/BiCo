import re
import shutil

# 1. Дан набор чисел.  Необходимо найти в нём все числа меньше 4.
# Пример: "1 0 2 9 3 8 4 7 5 6 8 9 10 11 -1 -65 432 3 74".

a = "1 0 2 9 3 8 4 7 5 6 8 9 10 11 -1 -65 432 3 74"
num_list = a.split()
less_four_list = []

for number in num_list:
    if int(number) < 4:
        less_four_list.append(number)

print(' '.join(less_four_list))

# 2. Дана строка произвольной длины. В строке перечислены разнообразные
# символы, буквы разных алфавитов и прочее. Необходимо получить все буквы
# русского алфавита, а также все числа от 0 до 6.

a = 'ывфвй12314556789AsdaDSDwqegerteвфывфыЫФВ ыый'
reg_comp = re.compile("[А-ЯЁа-яё0-6]+")
founded_matches = re.findall(reg_comp, a)
print(founded_matches)

# 3. Дана строка произвольной длины, состоящая из одинаковых символов.
# Требуется написать два рег. выражения, которые бы возвращали первый символ
# и всю строку, соответственно.
# Пример строки: "11111111111111".

a = '2222222222222222'
reg_comp1 = re.compile("^.")
reg_comp2 = re.compile(".+")
founded_matches1 = re.findall(reg_comp1, a)
founded_matches2 = re.findall(reg_comp2, a)
print(founded_matches1)
print(founded_matches2)

# 4.  Дана строка "a1 b3 a8 c2 a9 d7 a4 e5 a3 f8 a0 g1".
# Требуется написать ОДНО регулярное выражение, которое бы сматчило
# только числа согласно следующему условию: если перед числом стоит буква «a»,
# то это число должно быть меньше 5, иначе – больше либо равно 5.

a = 'a1 b3 a8 c2 a9 d7 a4 e5 a3 f8 a0 g1'
reg_comp = re.compile("a([0-4])|.[^a]([5-9])")
founded_matches = re.findall(reg_comp, a)
print(founded_matches)

# 1 7 4 5 3 8 0 - эти числа нужны, не понимаю почему еще выдает пустые

# 5. Дана произвольная html-страница, необходимо получить содержимое всех
# тегов <div>, внутри которых находится минимум 5 подряд идущих цифр.
# Например: "<div>asd 764 1234457 абвы</div>"

a = '<div>asd 764 1234457 абвы</div>'
reg_comp = re.compile("<div>(.+\d{5}.+)<\/div>")
founded_matches = re.findall(reg_comp, a)
print(founded_matches)

# 6. Дан текст. Необходимо найти в нём все слова, состоящие из 5 букв.
# Пример текста:
# "дождь лопата два школа арбуз стройка пять дом голова бутан город шпала"

a = 'дождь лопата два школа арбуз стройка пять дом голова бутан город шпала'
words_list = a.split()
five_letter_words_list = []

for word in words_list:
    if len(word) == 5:
        five_letter_words_list.append(word)

print(five_letter_words_list)

# 8. Дан текст. Необходимо найти в нём все слова, содержащие букву "а".
# Пример текста:
# "дождь лопата два школа арбуз стройка пять дом голова бутан город шпала"

a = 'дождь лопата два школа арбуз стройка пять дом голова бутан город шпала'
letter_a = "а"
words_list = a.split()
a_words_list = []
other_words_list = []

for word in words_list:
    for symbol in word:
        if letter_a in symbol:
            a_words_list.append(word)
        else:
            other_words_list.append(word)

# Возврашает почему-то с повтором слов, примерно понимаю почему
print(a_words_list)

# 9. Дана строка, содержащая имя человека, и дано регулярное выражение:
# "/(?#Имя)[А-Я][а-я]+\s(?#Отчество)[А-Яа-я]+\s(?#Фамилия)(?:[а-я]+)/"
# Необходимо изменить последнюю подмаску (следующую за комментарием "Фамилия")
# так, чтобы регулярное выражение сработало и вернуло бы всю строку
# (изменять или добавлять символьные классы нельзя).
# Пример имени: "Иван Семенович Петров".


# Скобки не нужны, иначе будет матчить ТОЛЬКО фамилию, делалось все в 3 питоне,
# Поэтому модификатора u в конце нет, ?: тоже не нужно. Я уточнил, что
# \w должно упоминаться лишь 1 раз, т.к. остальные буквы есть в классе [а-я]
# Вообще тут вариантов несколько, но этот, на мой взгляд, самый оптимальный

a = 'Иван Семенович Петров'
reg_ex = re.compile("(?#Имя)[А-Я][а-я]+\s(?#Отчество)[А-Яа-я]+\s"
                      "(?#Фамилия)\w{1}[а-я]+")
founded_matches = re.findall(reg_ex, a)
print(founded_matches)

# 14*. Дан текст. Необходимо найти все предложения, в которых НЕ
# встречается слово "два". Предложения разделены точками.
# Точка используется исключительно как знак окончания предложения.
# Все предложения начинаются с заглавной буквы и больше заглавных букв
# в себе не содержат.
# Пример текста:
# Два на два – четыре. Три на три – девять. Два на четыре – восемь.
# Четыре на пять – двадцать. Восемь на два – шестнадцать.
# Семь на восемь – пятьдесят шесть. Шесть на четыре – двадцать четыре.
# Пять на два – десять.

a = "Два на два – четыре. Три на три – девять. " \
    "Два на четыре – восемь. Четыре на пять – двадцать. " \
    "Восемь на два – шестнадцать. Семь на восемь – пятьдесят шесть. " \
    "Шесть на четыре – двадцать четыре. Пять на два – десять."
needed_sentences_list = []
separated_a_by_dot_list = a.split('.')

for word in separated_a_by_dot_list:
    if 'два ' not in word.lower():
        needed_sentences_list.append(word)

print('.'.join(needed_sentences_list))

# 12. Дан текст в файле exercise12.html
# Требуется получить содержимое всех блоков "<div>",
# внутри которых нет других блоков "<div>".
# Регулярное выражение должно отрабатывать быстро
# даже при очень большой вложенности тегов.

'''
<table>
	<tr>
		<td>
			<div>
				<h1>Блок 1</h1>
				<div>Внутренний блок 1</div>
			</div>
		<td>
			<div>
				<h1>Блок 2</h1>Какой-то текст 2
			</div>
		</td>
	</tr>
	<tr>
		<td>
			<div>Какой-то текст 3
				<h1>Блок 3</h1>
				<div><strong>Внутренний блок</strong> 3</div>
			</div>
		</td>
	</tr>
</table>
'''

# Уже утро было, мозги начали кипеть, не смог доделать регулярку, нужно время

f = open('exercise12.html', 'r')
text = f.read()
reg_ex = re.compile(r'''<tr>\s*
    <td>\s*
        <div>\s*
            .*?<div>(.*)</div>.*
        </div>\s*
    </td>\s*
</tr>''', re.DOTALL | re.VERBOSE)

founded_matches = re.findall(reg_ex, text)
print(founded_matches)
